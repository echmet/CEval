//=============================================================================
// INLCUDES

#include <algorithm> // min, max
#include <cmath>
#include "alglib/alglib.h"
#include "functions.h"

#define M_1_SQRTPI (1.0 / sqrt(M_PI))

namespace myStd {

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// > Gauss >

//---------------------------------------------------------------------------
// > Gauss / TGauss >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TGauss::f(double x)
{
        double q = 1. / s * M_SQRT2 * M_1_SQRTPI;
        double z = -(x - u)*(x - u) / 2 / s / s;
        double g = a0 * q * myStd::Exp(z);

        return g;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TGauss::der()
{
        return new TGaussD1(a0, u, s);
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//---------------------------------------------------------------------------
// < Gauss / TGauss <

//---------------------------------------------------------------------------
// > Gauss / TGaussD1 >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TGaussD1::f(double x)
{
        double q = 1./s * M_SQRT2 * M_1_SQRTPI;
        double z = -(x - u)*(x - u) / 2 / s / s;
        double g = a0 * q * myStd::Exp(z);

        double dz = - 1./s/s * (x - u);

        return dz * g;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TGaussD1::der()
{
        return new TGaussD2(a0, u, s);
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//---------------------------------------------------------------------------
// < Gauss / TGaussD1 <

//---------------------------------------------------------------------------
// > Gauss / TGaussD2 >


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TGaussD2::f(double x)
{
        double q = 1./s * M_SQRT2 * M_1_SQRTPI;
        double z = -(x - u)*(x - u) / 2 / s / s;
        double g = a0 * q * myStd::Exp(z);

        double dz  = - 1./s/s * (x - u);
        double d2z = - 1./s/s;

        return (d2z + dz*dz) * g;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TGaussD2::der()
{
        return new TDER(this);
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//---------------------------------------------------------------------------
// < Gauss / TGaussD2 <

//---------------------------------------------------------------------------
// < Gauss <

//---------------------------------------------------------------------------
// > HVL >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double THVL::f(double x)
{

        if (a3 == 0) return TGauss::f(x);

        const double u  = a1;
        const double s  = a2;

        const double k  = HVLFACTOR;
        const double kr = 1. / k;

        const double sqrtz = (x - u) * M_SQRT2 / s;
        const double g     = a0/s * M_SQRT2 * M_1_SQRTPI * myStd::Exp(-sqrtz*sqrtz);
        const double b1    = 1. / ( myStd::Exp(std::log(kr) + a3) - kr );
        const double b2    = 0.5 * k * ( 1. + AlgLib::erf(sqrtz) );

#if !HVLDEBUG

        return k / a3 * g / (b1 + b2);

#else

        return g;

#endif

}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * THVL::der()
{
        return new TDER(this);
}

//---------------------------------------------------------------------------
// < HVL <

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// > Adaptors >

//---------------------------------------------------------------------------
// > Adaptors / DER >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TDER::f(double x)
{
        return (fce(x+dx) - fce(x-dx)) / 2. / dx;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TDER::der()
{
        return new TDER(function(this));
}

//---------------------------------------------------------------------------
// < Adaptors / DER <

//---------------------------------------------------------------------------
// > Adaptors / DELTA >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TDELTA::f(double x)
{
        return fce1(x) - fce2(x);
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TDELTA::der()
{
        return new TDELTA(function(fce1.der()), function(fce2.der()));
}

//---------------------------------------------------------------------------
// < Adaptors / DELTA <

//---------------------------------------------------------------------------
// > Adaptors / MIN >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TMIN::f(double x)
{
        return std::min( fce1(x), fce2(x) );
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TMIN::der()
{
        return new TDER(function(this));
}

//---------------------------------------------------------------------------
// < Adaptors / MIN <

//---------------------------------------------------------------------------
// > Adaptors / TIMES >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TTIMES::f(double x)
{
        return fce1(x) * fce2(x);
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TTIMES::der()
{
        return new TDER(function(this));
}

//---------------------------------------------------------------------------
// < Adaptors / TIMES <

//---------------------------------------------------------------------------
// > Adaptors / POW >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TPOW::f(double x)
{
        return std::pow(fce(x), pow);
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TPOW::der()
{
        return new TDER(function(this));
}

//---------------------------------------------------------------------------
// < Adaptors / TIMES <

//---------------------------------------------------------------------------
// > Adaptors / MOMENT >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double TMOMENT::f(double x)
{
        return std::pow(x - c, k) * fce(x);
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function_base * TMOMENT::der()
{
        return new TDER(function(this));
}

//---------------------------------------------------------------------------
// < Adaptors / MOMENT <

//---------------------------------------------------------------------------
// < Adaptors <

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// > Algorithms >

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
std::pair<double, double>
solve(const function & f, double x1, double x2, double c, double eps, int max)
{

        double d1 = f(x1) - c;
        double d2 = f(x2) - c;

        if ( ( d1 > 0 && d2 > 0 ) || ( d1 < 0 && d2 < 0 )) goto END;

        if (d1 < 0) { ::std::swap(d1, d2); ::std::swap(x1, x2); }

        while (
                (
                        (	::std::fabs(d1) > eps && ::std::fabs(d2) > eps ) ||
                        ::std::fabs(x1 - x2) > eps
                ) &&
                max--
        )
        {

# if false

                        double k = ( d2 - d1 ) / ( x2 - x1 );

                        double x =  k > eps ? - ( d1 - k * x1 ) / k : x1;
                        if ( x >= ::std::max(x1, x2) || x <= ::std::min(x1, x2) ) x = (x1 + x2) / 2;

# else

                        double x = (x1 + x2) / 2;

# endif

                double d = f(x) - c;

                if (d > 0) { d1 = d; x1 = x; }
                else       { d2 = d; x2 = x; }

        }


END:;

        return ::std::fabs(d1) < ::std::fabs(d2) ?
                                 ::std::make_pair(x1, d1 + c)      :
                                 ::std::make_pair(x2, d2 + c)
        ;

}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double integral(const function & f, double x1, double x2, double dx)
{

        double x;
        double result;

        for (x = x1, result = 0; x <= x2; x += dx) result += f(x);

        return dx * (result - 0.5 * (f(x1) + f(x)) );

}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//---------------------------------------------------------------------------
// < Algorithms <

//===========================================================================
} // namespace

